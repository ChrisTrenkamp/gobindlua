// Code generated by gobindlua; DO NOT EDIT.
package pointers

import (
	"fmt"

	"github.com/ChrisTrenkamp/gobindlua"
	lua "github.com/yuin/gopher-lua"
)

func (goType *SomeStruct) LuaModuleName() string {
	return "some_struct"
}

func (goType *SomeStruct) LuaModuleLoader(L *lua.LState) int {
	staticMethodsTable := L.NewTable()

	L.Push(staticMethodsTable)

	return 1
}

func (goType *SomeStruct) LuaRegisterGlobalMetatable(L *lua.LState) {
	fieldsTable := L.NewTypeMetatable(goType.LuaMetatableType())
	L.SetGlobal(goType.LuaMetatableType(), fieldsTable)
	L.SetField(fieldsTable, "__index", L.NewFunction(luaAccessSomeStruct))
	L.SetField(fieldsTable, "__newindex", L.NewFunction(luaSetSomeStruct))
}

func (r *SomeStruct) LuaMetatableType() string {
	return "some_struct_fields"
}

func luaCheckSomeStruct(param int, L *lua.LState) *SomeStruct {
	ud := L.CheckUserData(param)
	v, ok := ud.Value.(*SomeStruct)
	if !ok {
		gobindlua.CastArgError(L, 1, "SomeStruct", ud.Value)
	}
	return v
}

func luaAccessSomeStruct(L *lua.LState) int {
	p1 := luaCheckSomeStruct(1, L)
	p2 := L.CheckString(2)

	switch p2 {
	case "a":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaMap{
			Map: p1.A,
			Len: func() int { return len(*p1.A) },
			GetValue: func(key0 lua.LValue) lua.LValue {

				keyVal0_n, ok := key0.(lua.LString)

				if !ok {
					gobindlua.TableElemCastError(L, 1, "string", key0)
				}

				keyVal0 := string(keyVal0_n)

				ret0 := (*p1.A)[(*string)(&keyVal0)]
				return gobindlua.NewUserData(&gobindlua.LuaMap{
					Map: ret0,
					Len: func() int { return len(*ret0) },
					GetValue: func(key1 lua.LValue) lua.LValue {

						keyVal1_n, ok := key1.(lua.LString)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "string", key1)
						}

						keyVal1 := string(keyVal1_n)

						ret1 := (*ret0)[(string)(keyVal1)]
						return gobindlua.NewUserData(&gobindlua.LuaArray{
							Slice: ret1,
							Len:   func() int { return len(*ret1) },
							Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
							SetIndex: func(idx2 int, val2 lua.LValue) {

								t2_n, ok := val2.(lua.LString)

								if !ok {
									gobindlua.TableElemCastError(L, 3, "string", val2)
								}

								t2 := string(t2_n)

								(*ret1)[idx2] = t2
							},
						}, L)
					},
					SetValue: func(key1 lua.LValue, val1 lua.LValue) {

						keyVal1_n, ok := key1.(lua.LString)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "string", key1)
						}

						keyVal1 := string(keyVal1_n)

						valVal1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, 2, func(val2 lua.LValue) string {

							v2_n, ok := val2.(lua.LString)

							if !ok {
								gobindlua.TableElemCastError(L, 3, "string", val2)
							}

							v2 := string(v2_n)

							return v2
						})

						if err != nil {
							L.ArgError(3, err.Error())
						}

						(*ret0)[(string)(keyVal1)] = (*[]string)(&valVal1)
					},
					ForEach: func(f1 func(k1, v1 lua.LValue)) {
						for k1_iter, v1_iter := range *ret0 {
							retKey1 := k1_iter
							ret1 := v1_iter
							key1 := (lua.LString)(retKey1)
							val1 := gobindlua.NewUserData(&gobindlua.LuaArray{
								Slice: ret1,
								Len:   func() int { return len(*ret1) },
								Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
								SetIndex: func(idx2 int, val2 lua.LValue) {

									t2_n, ok := val2.(lua.LString)

									if !ok {
										gobindlua.TableElemCastError(L, 3, "string", val2)
									}

									t2 := string(t2_n)

									(*ret1)[idx2] = t2
								},
							}, L)
							f1(key1, val1)
						}
					},
				}, L)
			},
			SetValue: func(key0 lua.LValue, val0 lua.LValue) {

				keyVal0_n, ok := key0.(lua.LString)

				if !ok {
					gobindlua.TableElemCastError(L, 1, "string", key0)
				}

				keyVal0 := string(keyVal0_n)

				valVal0, err := gobindlua.MapLuaArrayOrTableToGoMap[string, *[]string](val0, 1, func(key1, val1 lua.LValue) (string, *[]string) {

					k1_n, ok := key1.(lua.LString)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "string", key1)
					}

					k1 := string(k1_n)

					v1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, 2, func(val2 lua.LValue) string {

						v2_n, ok := val2.(lua.LString)

						if !ok {
							gobindlua.TableElemCastError(L, 3, "string", val2)
						}

						v2 := string(v2_n)

						return v2
					})

					if err != nil {
						L.ArgError(3, err.Error())
					}

					return k1, &v1
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.A)[(*string)(&keyVal0)] = (*map[string]*[]string)(&valVal0)
			},
			ForEach: func(f0 func(k0, v0 lua.LValue)) {
				for k0_iter, v0_iter := range *p1.A {
					retKey0 := k0_iter
					ret0 := v0_iter
					key0 := (lua.LString)(*retKey0)
					val0 := gobindlua.NewUserData(&gobindlua.LuaMap{
						Map: ret0,
						Len: func() int { return len(*ret0) },
						GetValue: func(key1 lua.LValue) lua.LValue {

							keyVal1_n, ok := key1.(lua.LString)

							if !ok {
								gobindlua.TableElemCastError(L, 2, "string", key1)
							}

							keyVal1 := string(keyVal1_n)

							ret1 := (*ret0)[(string)(keyVal1)]
							return gobindlua.NewUserData(&gobindlua.LuaArray{
								Slice: ret1,
								Len:   func() int { return len(*ret1) },
								Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
								SetIndex: func(idx2 int, val2 lua.LValue) {

									t2_n, ok := val2.(lua.LString)

									if !ok {
										gobindlua.TableElemCastError(L, 3, "string", val2)
									}

									t2 := string(t2_n)

									(*ret1)[idx2] = t2
								},
							}, L)
						},
						SetValue: func(key1 lua.LValue, val1 lua.LValue) {

							keyVal1_n, ok := key1.(lua.LString)

							if !ok {
								gobindlua.TableElemCastError(L, 2, "string", key1)
							}

							keyVal1 := string(keyVal1_n)

							valVal1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, 2, func(val2 lua.LValue) string {

								v2_n, ok := val2.(lua.LString)

								if !ok {
									gobindlua.TableElemCastError(L, 3, "string", val2)
								}

								v2 := string(v2_n)

								return v2
							})

							if err != nil {
								L.ArgError(3, err.Error())
							}

							(*ret0)[(string)(keyVal1)] = (*[]string)(&valVal1)
						},
						ForEach: func(f1 func(k1, v1 lua.LValue)) {
							for k1_iter, v1_iter := range *ret0 {
								retKey1 := k1_iter
								ret1 := v1_iter
								key1 := (lua.LString)(retKey1)
								val1 := gobindlua.NewUserData(&gobindlua.LuaArray{
									Slice: ret1,
									Len:   func() int { return len(*ret1) },
									Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
									SetIndex: func(idx2 int, val2 lua.LValue) {

										t2_n, ok := val2.(lua.LString)

										if !ok {
											gobindlua.TableElemCastError(L, 3, "string", val2)
										}

										t2 := string(t2_n)

										(*ret1)[idx2] = t2
									},
								}, L)
								f1(key1, val1)
							}
						},
					}, L)
					f0(key0, val0)
				}
			},
		}, L))

	case "b":
		L.Push(gobindlua.NewUserData(p1.B, L))

	case "c":
		L.Push(gobindlua.NewUserData(&p1.C, L))

	case "d":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.D,
			Len:   func() int { return len(*p1.D) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaArray{
					Slice: (*p1.D)[idx0],
					Len:   func() int { return len(*(*p1.D)[idx0]) },
					Index: func(idx1 int) lua.LValue { return (lua.LNumber)(*(*(*p1.D)[idx0])[idx1]) },
					SetIndex: func(idx1 int, val1 lua.LValue) {

						t1_n, ok := val1.(lua.LNumber)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "int", val1)
						}

						t1 := int(t1_n)

						(*(*p1.D)[idx0])[idx1] = &t1
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*int](val0, 1, func(val1 lua.LValue) *int {

					v1_n, ok := val1.(lua.LNumber)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "int", val1)
					}

					v1 := int(v1_n)

					return &v1
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.D)[idx0] = &t0
			},
		}, L))

	case "e":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.E,
			Len:   func() int { return len(*p1.E) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaArray{
					Slice: (*p1.E)[idx0],
					Len:   func() int { return len((*p1.E)[idx0]) },
					Index: func(idx1 int) lua.LValue { return gobindlua.NewUserData(((*p1.E)[idx0])[idx1], L) },
					SetIndex: func(idx1 int, val1 lua.LValue) {

						t1_ud, ok := val1.(*lua.LUserData)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", val1)
						}

						t1, ok := t1_ud.Value.(*Sub)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", val1)
						}

						((*p1.E)[idx0])[idx1] = t1
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*Sub](val0, 1, func(val1 lua.LValue) *Sub {

					v1_ud, ok := val1.(*lua.LUserData)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "Sub", val1)
					}

					v1, ok := v1_ud.Value.(*Sub)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "Sub", val1)
					}

					return v1
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.E)[idx0] = t0
			},
		}, L))

	case "f":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.F,
			Len:   func() int { return len(p1.F) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaMap{
					Map: (p1.F)[idx0],
					Len: func() int { return len((p1.F)[idx0]) },
					GetValue: func(key1 lua.LValue) lua.LValue {

						keyVal1_ud, ok := key1.(*lua.LUserData)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", key1)
						}

						keyVal1, ok := keyVal1_ud.Value.(*Sub)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", key1)
						}

						ret1 := ((p1.F)[idx0])[(*Sub)(keyVal1)]
						return (lua.LNumber)(*(ret1))
					},
					SetValue: func(key1 lua.LValue, val1 lua.LValue) {

						keyVal1_ud, ok := key1.(*lua.LUserData)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", key1)
						}

						keyVal1, ok := keyVal1_ud.Value.(*Sub)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "Sub", key1)
						}

						valVal1_n, ok := val1.(lua.LNumber)

						if !ok {
							gobindlua.TableElemCastError(L, 2, "int", val1)
						}

						valVal1 := int(valVal1_n)

						((p1.F)[idx0])[(*Sub)(keyVal1)] = (*int)(&valVal1)
					},
					ForEach: func(f1 func(k1, v1 lua.LValue)) {
						for k1_iter, v1_iter := range (p1.F)[idx0] {
							retKey1 := k1_iter
							ret1 := v1_iter
							key1 := gobindlua.NewUserData(retKey1, L)
							val1 := (lua.LNumber)(*ret1)
							f1(key1, val1)
						}
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoMap[*Sub, *int](val0, 1, func(key1, val1 lua.LValue) (*Sub, *int) {

					k1_ud, ok := key1.(*lua.LUserData)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "Sub", key1)
					}

					k1, ok := k1_ud.Value.(*Sub)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "Sub", key1)
					}

					v1_n, ok := val1.(lua.LNumber)

					if !ok {
						gobindlua.TableElemCastError(L, 2, "int", val1)
					}

					v1 := int(v1_n)

					return k1, &v1
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(p1.F)[idx0] = t0
			},
		}, L))

	default:
		L.Push(lua.LNil)
	}

	return 1
}

func luaSetSomeStruct(L *lua.LState) int {
	p1 := luaCheckSomeStruct(1, L)
	p2 := L.CheckString(2)

	switch p2 {
	case "a":

		ud, err := gobindlua.MapLuaArrayOrTableToGoMap[*string, *map[string]*[]string](L.CheckAny(3), 0, func(key0, val0 lua.LValue) (*string, *map[string]*[]string) {

			k0_n, ok := key0.(lua.LString)

			if !ok {
				gobindlua.TableElemCastError(L, 1, "string", key0)
			}

			k0 := string(k0_n)

			v0, err := gobindlua.MapLuaArrayOrTableToGoMap[string, *[]string](val0, 1, func(key1, val1 lua.LValue) (string, *[]string) {

				k1_n, ok := key1.(lua.LString)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "string", key1)
				}

				k1 := string(k1_n)

				v1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, 2, func(val2 lua.LValue) string {

					v2_n, ok := val2.(lua.LString)

					if !ok {
						gobindlua.TableElemCastError(L, 3, "string", val2)
					}

					v2 := string(v2_n)

					return v2
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				return k1, &v1
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return &k0, &v0
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.A = &ud

	case "b":

		ud, ok := L.CheckUserData(3).Value.(*Sub)

		if !ok {
			gobindlua.CastArgError(L, 3, "Sub", L.CheckUserData(3))
		}

		p1.B = ud

	case "c":

		ud, ok := L.CheckUserData(3).Value.(*Sub)

		if !ok {
			gobindlua.CastArgError(L, 3, "Sub", L.CheckUserData(3))
		}

		p1.C = *ud

	case "d":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[*[]*int](L.CheckAny(3), 0, func(val0 lua.LValue) *[]*int {

			v0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*int](val0, 1, func(val1 lua.LValue) *int {

				v1_n, ok := val1.(lua.LNumber)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "int", val1)
				}

				v1 := int(v1_n)

				return &v1
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return &v0
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.D = &ud

	case "e":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[[]*Sub](L.CheckAny(3), 0, func(val0 lua.LValue) []*Sub {

			v0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*Sub](val0, 1, func(val1 lua.LValue) *Sub {

				v1_ud, ok := val1.(*lua.LUserData)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "Sub", val1)
				}

				v1, ok := v1_ud.Value.(*Sub)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "Sub", val1)
				}

				return v1
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return v0
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.E = &ud

	case "f":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[map[*Sub]*int](L.CheckAny(3), 0, func(val0 lua.LValue) map[*Sub]*int {

			v0, err := gobindlua.MapLuaArrayOrTableToGoMap[*Sub, *int](val0, 1, func(key1, val1 lua.LValue) (*Sub, *int) {

				k1_ud, ok := key1.(*lua.LUserData)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "Sub", key1)
				}

				k1, ok := k1_ud.Value.(*Sub)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "Sub", key1)
				}

				v1_n, ok := val1.(lua.LNumber)

				if !ok {
					gobindlua.TableElemCastError(L, 2, "int", val1)
				}

				v1 := int(v1_n)

				return k1, &v1
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return v0
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.F = ud

	default:
		L.ArgError(2, fmt.Sprintf("unknown field %s", p2))
	}

	return 0
}
