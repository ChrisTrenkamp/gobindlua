// Code generated by gobindlua; DO NOT EDIT.
package pointers

import (
	"github.com/ChrisTrenkamp/gobindlua"
	lua "github.com/yuin/gopher-lua"
)

func (goType SomeStruct) RegisterLuaType(L *lua.LState) {
	staticMethodsTable := L.NewTypeMetatable("some_struct")
	L.SetGlobal("some_struct", staticMethodsTable)

	fieldsTable := L.NewTypeMetatable(goType.LuaMetatableType())
	L.SetGlobal(goType.LuaMetatableType(), fieldsTable)
	L.SetField(fieldsTable, "__index", L.NewFunction(luaAccessSomeStruct))
	L.SetField(fieldsTable, "__newindex", L.NewFunction(luaSetSomeStruct))
}

func (r *SomeStruct) LuaMetatableType() string {
	return "some_struct_fields"
}

func luaCheckSomeStruct(param int, L *lua.LState) *SomeStruct {
	ud := L.CheckUserData(param)
	if v, ok := ud.Value.(*SomeStruct); ok {
		return v
	}
	L.ArgError(1, "SomeStruct expected")
	return nil
}

func luaAccessSomeStruct(L *lua.LState) int {
	p1 := luaCheckSomeStruct(1, L)
	p2 := L.CheckString(2)

	switch p2 {
	case "a":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaMap{
			Map: p1.A,
			Len: func() int { return len(*p1.A) },
			GetValue: func(key0 lua.LValue) lua.LValue {

				keyVal0_n, ok := key0.(lua.LString)

				if !ok {
					L.ArgError(3, "argument not a string instance")
				}

				keyVal0 := string(keyVal0_n)

				ret0 := (*p1.A)[(*string)(&keyVal0)]
				return gobindlua.NewUserData(&gobindlua.LuaMap{
					Map: ret0,
					Len: func() int { return len(*ret0) },
					GetValue: func(key1 lua.LValue) lua.LValue {

						keyVal1, ok := key1.(lua.LString)

						if !ok {
							L.ArgError(3, "argument not a string instance")
						}

						ret1 := (*ret0)[(string)(keyVal1)]
						return gobindlua.NewUserData(&gobindlua.LuaArray{
							Slice: ret1,
							Len:   func() int { return len(*ret1) },
							Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
							SetIndex: func(idx2 int, val2 lua.LValue) {

								t2, ok := val2.(lua.LString)

								if !ok {
									L.ArgError(3, "argument not a string instance")
								}

								(*ret1)[idx2] = (string)(t2)
							},
						}, L)
					},
					SetValue: func(key1 lua.LValue, val1 lua.LValue) {

						keyVal1, ok := key1.(lua.LString)

						if !ok {
							L.ArgError(3, "argument not a string instance")
						}

						valVal1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, func(val2 lua.LValue) string {

							v2, ok := val2.(lua.LString)

							if !ok {
								L.ArgError(3, "argument not a string instance")
							}

							return (string)(v2)
						})

						if err != nil {
							L.ArgError(3, err.Error())
						}

						(*ret0)[(string)(keyVal1)] = (*[]string)(&valVal1)
					},
					ForEach: func(f1 func(k1, v1 lua.LValue)) {
						for k1_iter, v1_iter := range *ret0 {
							retKey1 := k1_iter
							ret1 := v1_iter
							key1 := (lua.LString)(retKey1)
							val1 := gobindlua.NewUserData(&gobindlua.LuaArray{
								Slice: ret1,
								Len:   func() int { return len(*ret1) },
								Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
								SetIndex: func(idx2 int, val2 lua.LValue) {

									t2, ok := val2.(lua.LString)

									if !ok {
										L.ArgError(3, "argument not a string instance")
									}

									(*ret1)[idx2] = (string)(t2)
								},
							}, L)
							f1(key1, val1)
						}
					},
				}, L)
			},
			SetValue: func(key0 lua.LValue, val0 lua.LValue) {

				keyVal0_n, ok := key0.(lua.LString)

				if !ok {
					L.ArgError(3, "argument not a string instance")
				}

				keyVal0 := string(keyVal0_n)

				valVal0, err := gobindlua.MapLuaArrayOrTableToGoMap[string, *[]string](val0, func(key1, val1 lua.LValue) (string, *[]string) {

					k1, ok := key1.(lua.LString)

					if !ok {
						L.ArgError(3, "argument not a string instance")
					}

					v1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, func(val2 lua.LValue) string {

						v2, ok := val2.(lua.LString)

						if !ok {
							L.ArgError(3, "argument not a string instance")
						}

						return (string)(v2)
					})

					if err != nil {
						L.ArgError(3, err.Error())
					}

					return (string)(k1), (*[]string)(&v1)
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.A)[(*string)(&keyVal0)] = (*map[string]*[]string)(&valVal0)
			},
			ForEach: func(f0 func(k0, v0 lua.LValue)) {
				for k0_iter, v0_iter := range *p1.A {
					retKey0 := k0_iter
					ret0 := v0_iter
					key0 := (lua.LString)(*retKey0)
					val0 := gobindlua.NewUserData(&gobindlua.LuaMap{
						Map: ret0,
						Len: func() int { return len(*ret0) },
						GetValue: func(key1 lua.LValue) lua.LValue {

							keyVal1, ok := key1.(lua.LString)

							if !ok {
								L.ArgError(3, "argument not a string instance")
							}

							ret1 := (*ret0)[(string)(keyVal1)]
							return gobindlua.NewUserData(&gobindlua.LuaArray{
								Slice: ret1,
								Len:   func() int { return len(*ret1) },
								Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
								SetIndex: func(idx2 int, val2 lua.LValue) {

									t2, ok := val2.(lua.LString)

									if !ok {
										L.ArgError(3, "argument not a string instance")
									}

									(*ret1)[idx2] = (string)(t2)
								},
							}, L)
						},
						SetValue: func(key1 lua.LValue, val1 lua.LValue) {

							keyVal1, ok := key1.(lua.LString)

							if !ok {
								L.ArgError(3, "argument not a string instance")
							}

							valVal1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, func(val2 lua.LValue) string {

								v2, ok := val2.(lua.LString)

								if !ok {
									L.ArgError(3, "argument not a string instance")
								}

								return (string)(v2)
							})

							if err != nil {
								L.ArgError(3, err.Error())
							}

							(*ret0)[(string)(keyVal1)] = (*[]string)(&valVal1)
						},
						ForEach: func(f1 func(k1, v1 lua.LValue)) {
							for k1_iter, v1_iter := range *ret0 {
								retKey1 := k1_iter
								ret1 := v1_iter
								key1 := (lua.LString)(retKey1)
								val1 := gobindlua.NewUserData(&gobindlua.LuaArray{
									Slice: ret1,
									Len:   func() int { return len(*ret1) },
									Index: func(idx2 int) lua.LValue { return (lua.LString)((*ret1)[idx2]) },
									SetIndex: func(idx2 int, val2 lua.LValue) {

										t2, ok := val2.(lua.LString)

										if !ok {
											L.ArgError(3, "argument not a string instance")
										}

										(*ret1)[idx2] = (string)(t2)
									},
								}, L)
								f1(key1, val1)
							}
						},
					}, L)
					f0(key0, val0)
				}
			},
		}, L))

	case "b":
		L.Push(gobindlua.NewUserData(p1.B, L))

	case "c":
		L.Push(gobindlua.NewUserData(&p1.C, L))

	case "d":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.D,
			Len:   func() int { return len(*p1.D) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaArray{
					Slice: (*p1.D)[idx0],
					Len:   func() int { return len(*(*p1.D)[idx0]) },
					Index: func(idx1 int) lua.LValue { return (lua.LNumber)(*(*(*p1.D)[idx0])[idx1]) },
					SetIndex: func(idx1 int, val1 lua.LValue) {

						t1_n, ok := val1.(lua.LNumber)

						if !ok {
							L.ArgError(3, "argument not a int instance")
						}

						t1 := int(t1_n)

						(*(*p1.D)[idx0])[idx1] = (*int)(&t1)
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*int](val0, func(val1 lua.LValue) *int {

					v1_n, ok := val1.(lua.LNumber)

					if !ok {
						L.ArgError(3, "argument not a int instance")
					}

					v1 := int(v1_n)

					return (*int)(&v1)
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.D)[idx0] = (*[]*int)(&t0)
			},
		}, L))

	case "e":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.E,
			Len:   func() int { return len(*p1.E) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaArray{
					Slice: (*p1.E)[idx0],
					Len:   func() int { return len((*p1.E)[idx0]) },
					Index: func(idx1 int) lua.LValue { return gobindlua.NewUserData(((*p1.E)[idx0])[idx1], L) },
					SetIndex: func(idx1 int, val1 lua.LValue) {

						t1_ud, ok := val1.(*lua.LUserData)

						if !ok {
							L.ArgError(3, "UserData expected")
						}

						t1, ok := t1_ud.Value.(*Sub)

						if !ok {
							L.ArgError(3, "Sub expected")
						}

						((*p1.E)[idx0])[idx1] = (*Sub)(t1)
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*Sub](val0, func(val1 lua.LValue) *Sub {

					v1_ud, ok := val1.(*lua.LUserData)

					if !ok {
						L.ArgError(3, "UserData expected")
					}

					v1, ok := v1_ud.Value.(*Sub)

					if !ok {
						L.ArgError(3, "Sub expected")
					}

					return (*Sub)(v1)
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(*p1.E)[idx0] = ([]*Sub)(t0)
			},
		}, L))

	case "f":
		L.Push(gobindlua.NewUserData(&gobindlua.LuaArray{
			Slice: p1.F,
			Len:   func() int { return len(p1.F) },
			Index: func(idx0 int) lua.LValue {
				return gobindlua.NewUserData(&gobindlua.LuaMap{
					Map: (p1.F)[idx0],
					Len: func() int { return len((p1.F)[idx0]) },
					GetValue: func(key1 lua.LValue) lua.LValue {

						keyVal1_ud, ok := key1.(*lua.LUserData)

						if !ok {
							L.ArgError(3, "UserData expected")
						}

						keyVal1, ok := keyVal1_ud.Value.(*Sub)

						if !ok {
							L.ArgError(3, "Sub expected")
						}

						ret1 := ((p1.F)[idx0])[(*Sub)(keyVal1)]
						return (lua.LNumber)(*(ret1))
					},
					SetValue: func(key1 lua.LValue, val1 lua.LValue) {

						keyVal1_ud, ok := key1.(*lua.LUserData)

						if !ok {
							L.ArgError(3, "UserData expected")
						}

						keyVal1, ok := keyVal1_ud.Value.(*Sub)

						if !ok {
							L.ArgError(3, "Sub expected")
						}

						valVal1_n, ok := val1.(lua.LNumber)

						if !ok {
							L.ArgError(3, "argument not a int instance")
						}

						valVal1 := int(valVal1_n)

						((p1.F)[idx0])[(*Sub)(keyVal1)] = (*int)(&valVal1)
					},
					ForEach: func(f1 func(k1, v1 lua.LValue)) {
						for k1_iter, v1_iter := range (p1.F)[idx0] {
							retKey1 := k1_iter
							ret1 := v1_iter
							key1 := gobindlua.NewUserData(retKey1, L)
							val1 := (lua.LNumber)(*ret1)
							f1(key1, val1)
						}
					},
				}, L)
			},
			SetIndex: func(idx0 int, val0 lua.LValue) {

				t0, err := gobindlua.MapLuaArrayOrTableToGoMap[*Sub, *int](val0, func(key1, val1 lua.LValue) (*Sub, *int) {

					k1_ud, ok := key1.(*lua.LUserData)

					if !ok {
						L.ArgError(3, "UserData expected")
					}

					k1, ok := k1_ud.Value.(*Sub)

					if !ok {
						L.ArgError(3, "Sub expected")
					}

					v1_n, ok := val1.(lua.LNumber)

					if !ok {
						L.ArgError(3, "argument not a int instance")
					}

					v1 := int(v1_n)

					return (*Sub)(k1), (*int)(&v1)
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				(p1.F)[idx0] = (map[*Sub]*int)(t0)
			},
		}, L))
	}

	return 1
}

func luaSetSomeStruct(L *lua.LState) int {
	p1 := luaCheckSomeStruct(1, L)
	p2 := L.CheckString(2)

	switch p2 {
	case "a":

		ud, err := gobindlua.MapLuaArrayOrTableToGoMap[*string, *map[string]*[]string](L.CheckAny(3), func(key0, val0 lua.LValue) (*string, *map[string]*[]string) {

			k0_n, ok := key0.(lua.LString)

			if !ok {
				L.ArgError(3, "argument not a string instance")
			}

			k0 := string(k0_n)

			v0, err := gobindlua.MapLuaArrayOrTableToGoMap[string, *[]string](val0, func(key1, val1 lua.LValue) (string, *[]string) {

				k1, ok := key1.(lua.LString)

				if !ok {
					L.ArgError(3, "argument not a string instance")
				}

				v1, err := gobindlua.MapLuaArrayOrTableToGoSlice[string](val1, func(val2 lua.LValue) string {

					v2, ok := val2.(lua.LString)

					if !ok {
						L.ArgError(3, "argument not a string instance")
					}

					return (string)(v2)
				})

				if err != nil {
					L.ArgError(3, err.Error())
				}

				return (string)(k1), (*[]string)(&v1)
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return (*string)(&k0), (*map[string]*[]string)(&v0)
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.A = &ud

	case "b":

		ud, ok := L.CheckUserData(3).Value.(*Sub)

		if !ok {
			L.ArgError(3, "Sub expected")
		}

		p1.B = ud

	case "c":

		ud, ok := L.CheckUserData(3).Value.(*Sub)

		if !ok {
			L.ArgError(3, "Sub expected")
		}

		p1.C = *ud

	case "d":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[*[]*int](L.CheckAny(3), func(val0 lua.LValue) *[]*int {

			v0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*int](val0, func(val1 lua.LValue) *int {

				v1_n, ok := val1.(lua.LNumber)

				if !ok {
					L.ArgError(3, "argument not a int instance")
				}

				v1 := int(v1_n)

				return (*int)(&v1)
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return (*[]*int)(&v0)
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.D = &ud

	case "e":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[[]*Sub](L.CheckAny(3), func(val0 lua.LValue) []*Sub {

			v0, err := gobindlua.MapLuaArrayOrTableToGoSlice[*Sub](val0, func(val1 lua.LValue) *Sub {

				v1_ud, ok := val1.(*lua.LUserData)

				if !ok {
					L.ArgError(3, "UserData expected")
				}

				v1, ok := v1_ud.Value.(*Sub)

				if !ok {
					L.ArgError(3, "Sub expected")
				}

				return (*Sub)(v1)
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return ([]*Sub)(v0)
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.E = &ud

	case "f":

		ud, err := gobindlua.MapLuaArrayOrTableToGoSlice[map[*Sub]*int](L.CheckAny(3), func(val0 lua.LValue) map[*Sub]*int {

			v0, err := gobindlua.MapLuaArrayOrTableToGoMap[*Sub, *int](val0, func(key1, val1 lua.LValue) (*Sub, *int) {

				k1_ud, ok := key1.(*lua.LUserData)

				if !ok {
					L.ArgError(3, "UserData expected")
				}

				k1, ok := k1_ud.Value.(*Sub)

				if !ok {
					L.ArgError(3, "Sub expected")
				}

				v1_n, ok := val1.(lua.LNumber)

				if !ok {
					L.ArgError(3, "argument not a int instance")
				}

				v1 := int(v1_n)

				return (*Sub)(k1), (*int)(&v1)
			})

			if err != nil {
				L.ArgError(3, err.Error())
			}

			return (map[*Sub]*int)(v0)
		})

		if err != nil {
			L.ArgError(3, err.Error())
		}

		p1.F = ud
	}

	return 1
}
