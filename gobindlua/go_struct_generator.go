package main

import (
	"bytes"
	"fmt"
	"io"
	"text/template"

	"github.com/ChrisTrenkamp/gobindlua/gobindlua/functiontype"
	"golang.org/x/tools/imports"
)

func (g *StructGenerator) generateGoCode() ([]byte, error) {
	code := bytes.Buffer{}
	fmt.Fprintf(&code, "// Code generated by gobindlua; DO NOT EDIT.\n")
	fmt.Fprintf(&code, "package %s\n\nimport (\n", g.packageSource.Types.Name())
	for pkg, name := range g.imports {
		fmt.Fprintf(&code, "\t%s \"%s\"\n", name, pkg)
	}
	fmt.Fprintf(&code, ")\n")
	io.Copy(&code, &g.metatableInitFunction)
	io.Copy(&code, &g.metatableFunctions)
	io.Copy(&code, &g.userDataFunctions)

	originalCodeBytes := code.Bytes()
	formattedCode, err := imports.Process(g.pathToOutput, originalCodeBytes, nil)
	if err != nil {
		return originalCodeBytes, err
	}

	return formattedCode, nil
}

func (g *StructGenerator) buildMetatableInitFunction() {
	if g.structToGenerate == "" {
		templ := `
func {{ .PackageToGenerateFunctionName }}(L *lua.LState) {
	staticMethodsTable := L.NewTypeMetatable("{{ .PackageToGenerateMetatableName }}")
	L.SetGlobal("{{ .PackageToGenerateMetatableName }}", staticMethodsTable)
	{{ range $idx, $fn := .StaticFunctions -}}
		L.SetField(staticMethodsTable, "{{ $fn.LuaFnName }}", L.NewFunction({{ $fn.SourceFnName }}))
	{{ end }}
}
`

		execTempl(&g.metatableInitFunction, g, templ)
		return
	}

	templ := `
func (goType {{ .StructToGenerate }}) RegisterLuaType(L *lua.LState) {
	staticMethodsTable := L.NewTypeMetatable("{{ .StructMetatableIdentifier }}")
	L.SetGlobal("{{ .StructMetatableIdentifier }}", staticMethodsTable)
	{{ range $idx, $fn := .StaticFunctions -}}
		L.SetField(staticMethodsTable, "{{ $fn.LuaFnName }}", L.NewFunction({{ $fn.SourceFnName }}))
	{{ end }}
	fieldsTable := L.NewTypeMetatable(goType.LuaMetatableType())
	L.SetGlobal(goType.LuaMetatableType(), fieldsTable)
	L.SetField(fieldsTable, "__index", L.NewFunction({{ .SourceUserDataAccess }}))
	L.SetField(fieldsTable, "__newindex", L.NewFunction({{ .SourceUserDataSet }}))
}
`

	execTempl(&g.metatableInitFunction, g, templ)
}

func (g *StructGenerator) buildMetatableFunctions() {
	for _, i := range g.StaticFunctions {
		generateLuaFunctionWrapper(&g.metatableFunctions, g, i)
	}
}

func (g *StructGenerator) builderUserDataFunctions() {
	if g.structToGenerate == "" {
		return
	}

	g.generateUserDataPredefinitions()
	g.generateStructAccessFunction()
	g.generateStructSetFunction()
	g.generateStructMethods()
}

func (g *StructGenerator) generateUserDataPredefinitions() {
	templ := `
func (r *{{ .StructToGenerate }}) LuaMetatableType() string {
	return "{{ .StructMetatableFieldsIdentifier }}"
}

func {{ .UserDataCheckFn }}(param int, L *lua.LState) *{{ .StructToGenerate }} {
	ud := L.CheckUserData(param)
	if v, ok := ud.Value.(*{{ .StructToGenerate }}); ok {
		return v
	}
	L.ArgError(1, "{{ .StructToGenerate }} expected")
	return nil
}
`

	execTempl(&g.userDataFunctions, g, templ)
}

func (g *StructGenerator) generateStructAccessFunction() {
	templ := `
func {{ .SourceUserDataAccess }}(L *lua.LState) int {
	{{- if gt (len .Fields) 0 }}
	p1 := {{ .UserDataCheckFn }}(1, L)
	{{- end }}
	p2 := L.CheckString(2)

	switch p2 {
		{{- range $idx, $field := .Fields }}
	case "{{ $field.LuaName }}":
		L.Push({{ $field.DataType.ConvertGoTypeToLua (printf "p1.%s" $field.FieldName) }})
		{{ end -}}

		{{- range $idx, $method := .UserDataMethods }}
	case "{{ $method.LuaFnName }}":
		L.Push(L.NewFunction({{ $method.SourceFnName }}))
		{{ end }}

	default:
		L.Push(lua.LNil)
	}

	return 1
}
`

	execTempl(&g.userDataFunctions, g, templ)
}

func (g *StructGenerator) generateStructSetFunction() {
	templ := `
func {{ .SourceUserDataSet }}(L *lua.LState) int {
	{{- if gt (len .Fields) 0 }}
	p1 := {{ .UserDataCheckFn }}(1, L)
	{{- end }}
	p2 := L.CheckString(2)

	switch p2 {
		{{- range $idx, $field := .Fields }}
	case "{{ $field.LuaName }}":
		{{ $field.DataType.ConvertLuaTypeToGo "ud" (printf "%s(3)" $field.DataType.LuaParamType) 3 }}
		p1.{{ $field.FieldName }} = {{ $field.DataType.ReferenceOrDereferenceForAssignmentToField }}ud
		{{ end }}

	default:
		L.ArgError(2, fmt.Sprintf("unknown field %s", p2))
	}

	return 0
}
`

	execTempl(&g.userDataFunctions, g, templ)
}

func (g *StructGenerator) generateStructMethods() {
	for _, i := range g.UserDataMethods {
		generateLuaFunctionWrapper(&g.userDataFunctions, g, i)
	}
}

func generateLuaFunctionWrapper(out io.Writer, g *StructGenerator, f functiontype.FunctionType) {
	type FunctionGenerator struct {
		*StructGenerator
		*functiontype.FunctionType
	}

	templ := `
func {{ .FunctionType.SourceFnName }}(L *lua.LState) int {
	{{ if .FunctionType.Receiver -}}
		r := {{ .StructGenerator.UserDataCheckFn }}(1, L)
	{{- end }}
	{{ range $idx, $param := .Params }}
		var p{{ $idx }} {{ $param.TemplateArg }}
	{{ end }}
	{{ range $idx, $param := .Params }}
		{
			{{ $param.ConvertLuaTypeToGo "ud" (printf "%s(%d)" $param.LuaParamType $param.ParamNum) $param.ParamNum }}
			p{{ $idx }} = {{ $param.ReferenceOrDereferenceForAssignmentToField }}ud
		}
	{{ end }}
	{{ .FunctionType.GenerateReturnValues "r" }} {{ if .FunctionType.Receiver -}}r.{{ end }}{{ .FunctionType.ActualFnName  }}({{ .FunctionType.GenerateParamValues "p" }})

	{{ range $idx, $ret := .Ret -}}
		{{- if $ret.IsError -}}
			if r{{ $idx }} != nil {
				L.Error(lua.LString(r{{ $idx }}.Error()), 1)
			}
		{{- end -}}
	{{- end }}

	{{ range $idx, $ret := .Ret -}}
		{{- if not $ret.IsError -}}
			{{ $name := printf "r%d" $idx }}
			L.Push({{$ret.ConvertGoTypeToLua $name}})
		{{- end -}}
	{{- end }}

	return {{ .FunctionType.NumReturns }}
}
`

	execTempl(out, FunctionGenerator{g, &f}, templ)
}

func execTempl(out io.Writer, data any, templ string) {
	t := template.Must(template.New("").Parse(templ))
	err := t.Execute(out, data)

	if err != nil {
		panic(err)
	}
}
